// {{ project_name }} - Custom Scripts for shadcn theme

// Configuration
const CONFIG = {
  repoUrl: '{{ repo_url }}',
  repoName: '{{ repo_owner }}/{{ repo_name }}',
  customLinks: [] // Loaded from links.yml
};

// Load custom links from links.yml
async function loadCustomLinks() {
  try {
    const response = await fetch('./links.yml');
    if (!response.ok) return;
    const text = await response.text();
    
    // Simple YAML parser for our links format
    const links = [];
    const lines = text.split('\n');
    let currentLink = null;
    
    for (const line of lines) {
      const titleMatch = line.match(/^\s*-?\s*title:\s*["']?(.+?)["']?\s*$/);
      const urlMatch = line.match(/^\s*url:\s*["']?(.+?)["']?\s*$/);
      
      if (titleMatch) {
        if (currentLink && currentLink.url) links.push(currentLink);
        currentLink = { title: titleMatch[1] };
      } else if (urlMatch && currentLink) {
        currentLink.url = urlMatch[1];
      }
    }
    if (currentLink && currentLink.url) links.push(currentLink);
    
    CONFIG.customLinks = links;
    addCustomLinks(); // Re-run after loading
  } catch (e) {
    console.log('Could not load links.yml:', e);
  }
}

// Run on load and after delay
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, running init...');
  init();
  loadCustomLinks();
  setTimeout(init, 300);
  setTimeout(init, 1000);
});

function init() {
  console.log('Init running...');
  setupHeaderControls();
  setupCollapsibleNav();
  buildNestedNavigation();
  addCustomLinks();
  observeSidebarChanges();
  updateFooter();
  addVersionSelector();
  setupHeaderAnchors();
  fixCopyPageButton();
  setupGlobalCopyHandler();
  setupTabbedContent();
}

// ============================================
// FIX COPY PAGE BUTTON
// ============================================

function fixCopyPageButton() {
  const copyButtons = document.querySelectorAll('button[onclick*="clipboard"]');
  
  copyButtons.forEach(btn => {
    if (btn.dataset.copyFixed) return;
    btn.dataset.copyFixed = 'true';
    
    btn.removeAttribute('onclick');
    
    btn.addEventListener('click', async function(e) {
      e.preventDefault();
      
      try {
        const article = document.querySelector('article');
        if (!article) {
          console.error('No article found to copy');
          return;
        }
        
        const content = article.innerText || article.textContent;
        const contentWithFooter = appendCopyFooter(content);
        
        await navigator.clipboard.writeText(contentWithFooter);
        
        const span = btn.querySelector('span');
        if (span) {
          span.textContent = 'Copied!';
        }
        
        setTimeout(() => {
          if (span) {
            span.textContent = 'Copy Page';
          }
        }, 2000);
        
        console.log('Page content copied to clipboard');
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    });
  });
}

function appendCopyFooter(content) {
  const currentUrl = window.location.href.split('?')[0];
  const embedUrl = currentUrl + (currentUrl.includes('?') ? '&' : '?') + 'embed=true';
  const timestamp = new Date().toISOString().replace('T', ' ').split('.')[0] + ' UTC';
  
  const footer = `

---
This content was copied from ${currentUrl} at ${timestamp}.
Use of content is protected by a CC-BY-4.0 licence and external use is allowed at your own risk.

If you wish to embed a live version of this page please use: ${embedUrl}

Iframe example:
<iframe src="${embedUrl}" width="100%" height="600" frameborder="0"></iframe>
`;
  
  return content + footer;
}

function setupGlobalCopyHandler() {
  if (window.copyHandlerSetup) return;
  window.copyHandlerSetup = true;
  
  document.addEventListener('copy', function(e) {
    console.log('Copy event triggered');
    const selection = window.getSelection().toString();
    console.log('Selection length:', selection.length);
    
    if (selection && selection.length > 100) {
      e.preventDefault();
      const contentWithFooter = appendCopyFooter(selection);
      e.clipboardData.setData('text/plain', contentWithFooter);
      console.log('Copy intercepted, footer added');
    }
  }, true);
  
  console.log('Global copy handler installed');
}

setupGlobalCopyHandler();

// ============================================
// HEADER CONTROLS
// ============================================

function setupHeaderControls() {
  console.log('Header controls disabled to preserve Home link');
  return;
}

// ============================================
// COLLAPSIBLE NAVIGATION (shadcn structure)
// ============================================

function setupCollapsibleNav() {
  const groups = document.querySelectorAll('[data-slot="sidebar-group"]');
  
  console.log('Setting up collapsible navigation for', groups.length, 'groups');
  
  groups.forEach((group, index) => {
    // IMPORTANT: Use :scope > to only match DIRECT children, not nested labels
    const label = group.querySelector(':scope > [data-slot="sidebar-group-label"]');
    const content = group.querySelector(':scope > [data-slot="sidebar-group-content"]');
    
    // If no direct label, this is the root group - keep it always visible
    if (!label) {
      console.log(`Group ${index}: ROOT GROUP (no direct label), keeping expanded`);
      if (content) {
        content.style.display = 'block';
        content.style.visibility = 'visible';
        content.style.opacity = '1';
        content.style.maxHeight = 'none';
        content.style.pointerEvents = 'auto';
        // Mark as non-collapsible
        content.classList.add('root-content');
      }
      return;
    }
    
    if (!content) return;
    
    if (label.dataset.collapsibleSetup === 'done') return;
    label.dataset.collapsibleSetup = 'done';
    
    const groupName = label.textContent.trim();
    
    label.classList.add('nav-collapsible');
    content.classList.add('nav-children');
    
    const checkForActivePage = (element) => {
      const links = element.querySelectorAll('a[data-slot="sidebar-menu-button"]');
      for (const link of links) {
        if (link.getAttribute('data-active') === 'true') {
          return true;
        }
      }
      return false;
    };
    
    const containsCurrentPage = checkForActivePage(content);
    const initiallyExpanded = containsCurrentPage;
    
    if (initiallyExpanded) {
      label.classList.add('expanded');
      content.classList.remove('collapsed');
      content.style.maxHeight = '2000px';
      content.style.opacity = '1';
      content.style.pointerEvents = 'auto';
      console.log(`Group ${index} "${groupName}": EXPANDED (contains active page)`);
    } else {
      label.classList.remove('expanded');
      content.classList.add('collapsed');
      content.style.maxHeight = '0';
      content.style.opacity = '0';
      content.style.pointerEvents = 'none';
      console.log(`Group ${index} "${groupName}": COLLAPSED`);
    }
    
    label.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      const isExpanded = label.classList.contains('expanded');
      
      console.log(`Toggling "${groupName}": currently ${isExpanded ? 'expanded' : 'collapsed'}`);
      
      if (isExpanded) {
        label.classList.remove('expanded');
        content.classList.add('collapsed');
        content.style.maxHeight = '0';
        content.style.opacity = '0';
        content.style.pointerEvents = 'none';
        console.log(`  → Now COLLAPSED`);
      } else {
        label.classList.add('expanded');
        content.classList.remove('collapsed');
        content.style.maxHeight = '2000px';
        content.style.opacity = '1';
        content.style.pointerEvents = 'auto';
        console.log(`  → Now EXPANDED`);
      }
    });
  });
  
  const rootMenuItems = document.querySelectorAll('[data-slot="sidebar-menu"] > [data-slot="sidebar-menu-item"]');
  rootMenuItems.forEach(item => {
    item.style.display = 'block';
    item.style.visibility = 'visible';
    item.style.opacity = '1';
  });
  
  console.log('Collapsible nav setup complete');
}

// ============================================
// CUSTOM LINKS
// ============================================

function addCustomLinks() {
  if (!CONFIG.customLinks || CONFIG.customLinks.length === 0) return;
  
  const sidebarContent = document.querySelector('[data-slot="sidebar-content"]');
  if (!sidebarContent) return;
  
  // Check if links already exist in this sidebar
  if (sidebarContent.querySelector('.custom-links-section')) return;
  
  console.log('Adding custom links to sidebar');
  
  const section = document.createElement('div');
  section.className = 'custom-links-section';
  section.innerHTML = `
    <div class="custom-links-title">{{ links_section_title }}</div>
    <div class="custom-links-list">
      ${CONFIG.customLinks.map(link => `
        <a href="${link.url}" class="custom-link" target="_blank" rel="noopener">
          <span>${link.title}</span>
        </a>
      `).join('')}
    </div>
  `;
  
  sidebarContent.appendChild(section);
  console.log('Custom links added');
}

// Watch for sidebar changes and re-add links if needed
function observeSidebarChanges() {
  const sidebar = document.querySelector('[data-slot="sidebar"]');
  if (!sidebar) return;
  
  const observer = new MutationObserver((mutations) => {
    // Check if custom links section was removed
    if (!document.querySelector('.custom-links-section')) {
      console.log('Custom links removed, re-adding...');
      addCustomLinks();
    }
  });
  
  observer.observe(sidebar, { 
    childList: true, 
    subtree: true 
  });
}

// ============================================
// HEADER ANCHORS
// ============================================

function setupHeaderAnchors() {
  const content = document.querySelector('article, main, .content');
  if (!content) return;
  
  content.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]').forEach(header => {
    if (header.dataset.anchorSetup) return;
    header.dataset.anchorSetup = 'true';
    
    header.style.cursor = 'pointer';
    header.addEventListener('click', function(e) {
      if (e.target.tagName === 'A') return;
      window.location.hash = header.id;
      navigator.clipboard?.writeText(window.location.href.split('#')[0] + '#' + header.id);
    });
  });
}

// ============================================
// FOOTER
// ============================================

function updateFooter() {
  const shadcnFooter = document.querySelector('footer');
  if (shadcnFooter) {
    shadcnFooter.style.display = 'none';
  }
  
  if (document.querySelector('.md-footer')) return;
  
  const bottomNav = document.querySelector('.mx-auto.flex.flex-wrap.h-16');
  
  const footer = document.createElement('footer');
  footer.className = 'md-footer';
  
  const prevLink = bottomNav?.querySelector('a:first-of-type');
  const nextLink = bottomNav?.querySelector('a:last-of-type');
  
  let footerHTML = '<nav class="md-footer__inner">';
  
  if (prevLink && prevLink !== nextLink) {
    const prevTitle = prevLink.querySelector('span')?.textContent || prevLink.textContent.trim();
    const prevHref = prevLink.getAttribute('href');
    footerHTML += `
      <a href="${prevHref}" class="md-footer__link md-footer__link--prev" aria-label="Previous: ${prevTitle}">
        <div class="md-footer__button md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"></path>
          </svg>
        </div>
        <div class="md-footer__title">
          <span class="md-footer__direction">Previous</span>
          <div class="md-ellipsis">${prevTitle}</div>
        </div>
      </a>
    `;
  }
  
  if (nextLink) {
    const nextTitle = nextLink.querySelector('span')?.textContent || nextLink.textContent.trim();
    const nextHref = nextLink.getAttribute('href');
    footerHTML += `
      <a href="${nextHref}" class="md-footer__link md-footer__link--next" aria-label="Next: ${nextTitle}">
        <div class="md-footer__title">
          <span class="md-footer__direction">Next</span>
          <div class="md-ellipsis">${nextTitle}</div>
        </div>
        <div class="md-footer__button md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"></path>
          </svg>
        </div>
      </a>
    `;
  }
  
  footerHTML += '</nav>';
  footer.innerHTML = footerHTML;
  
  if (bottomNav) {
    bottomNav.style.display = 'none';
  }
  
  const main = document.querySelector('main');
  if (main) {
    main.appendChild(footer);
  }
  
  if (!document.querySelector('.footer-attribution')) {
    const attribution = document.createElement('div');
    attribution.className = 'footer-attribution';
    attribution.innerHTML = `
      <p>
        Built by <a href="https://github.com/wolfiex">Daniel Ellis</a>
        for <a href="https://wcrp-cmip.org">WCRP-CMIP</a>
        with a modified version of the <a href="https://github.com/asiffer/mkdocs-shadcn">shadcn</a> theme.
      </p>
    `;
    document.body.appendChild(attribution);
  }
}

// ============================================
// VERSION SELECTOR
// ============================================

function addVersionSelector() {
  if (document.querySelector('.version-selector')) return;
  
  // Try multiple paths to find versions.json
  const basePaths = [
    '',                    // Root
    '../',                 // One level up (if in version folder)
    '../../',              // Two levels up
    window.location.origin + '{{ url_prefix }}/',  // Absolute with prefix
  ];
  
  async function tryFetchVersions() {
    for (const base of basePaths) {
      try {
        const response = await fetch(base + 'versions.json');
        if (response.ok) {
          const versions = await response.json();
          if (versions?.length) return versions;
        }
      } catch (e) {}
    }
    return null;
  }
  
  tryFetchVersions().then(versions => {
    if (!versions?.length) {
      console.log('No versions.json found - version selector hidden');
      return;
    }
    
    console.log('Found versions:', versions.map(v => v.version).join(', '));

    const pathParts = window.location.pathname.split('/').filter(p => p);
    const current = versions.find(v => 
      pathParts.includes(v.version) || v.aliases?.some(a => pathParts.includes(a))
    );

    const dropdown = document.createElement('div');
    dropdown.className = 'version-selector';
    dropdown.innerHTML = `
      <select id="version-select" title="Documentation version">
        ${versions.map(v => `
          <option value="${v.version}" ${current?.version === v.version ? 'selected' : ''}>
            ${v.aliases?.includes('latest') ? `${v.version} (latest)` : v.version}
          </option>
        `).join('')}
      </select>
    `;

    const header = document.querySelector('header');
    const target = header?.querySelector('.ml-auto') || header;
    target?.insertBefore(dropdown, target.firstChild);

    dropdown.querySelector('select').addEventListener('change', e => {
      const newVersion = e.target.value;
      const path = window.location.pathname;
      
      if (current) {
        // Replace current version in path
        const pattern = new RegExp(`/(${current.version}|${current.aliases?.join('|') || ''})/`);
        window.location.href = path.replace(pattern, `/${newVersion}/`);
      } else {
        // Navigate to new version root
        window.location.href = `/${newVersion}/`;
      }
    });
  });
}

window.EMDCustom = { init, CONFIG };

// ============================================
// TABBED CONTENT SUPPORT
// ============================================

function setupTabbedContent() {
  const tabbedSets = document.querySelectorAll('.tabbed-set');
  
  tabbedSets.forEach(set => {
    if (set.dataset.tabbedSetup) return;
    set.dataset.tabbedSetup = 'true';
    
    const labels = set.querySelectorAll('.tabbed-labels > label');
    const inputs = set.querySelectorAll('input[type="radio"]');
    const blocks = set.querySelectorAll('.tabbed-content > .tabbed-block');
    
    const updateTabs = () => {
      const checkedIndex = Array.from(inputs).findIndex(input => input.checked);
      
      blocks.forEach((block, index) => {
        if (index === checkedIndex) {
          block.style.display = 'block';
          block.style.visibility = 'visible';
          block.style.opacity = '1';
          block.setAttribute('data-active', 'true');
        } else {
          block.style.display = 'none';
          block.setAttribute('data-active', 'false');
        }
      });
      
      labels.forEach((label, index) => {
        if (index === checkedIndex) {
          label.setAttribute('data-active', 'true');
        } else {
          label.setAttribute('data-active', 'false');
        }
      });
    };
    
    updateTabs();
    
    labels.forEach((label, index) => {
      label.setAttribute('tabindex', '0');
      label.setAttribute('role', 'tab');
      
      label.addEventListener('click', () => {
        if (inputs[index]) {
          inputs[index].checked = true;
          updateTabs();
        }
      });
      
      label.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          if (inputs[index]) {
            inputs[index].checked = true;
            updateTabs();
          }
        }
        
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
          e.preventDefault();
          const direction = e.key === 'ArrowLeft' ? -1 : 1;
          const newIndex = (index + direction + labels.length) % labels.length;
          labels[newIndex].focus();
          if (inputs[newIndex]) {
            inputs[newIndex].checked = true;
            updateTabs();
          }
        }
      });
      
      if (inputs[index]) {
        inputs[index].addEventListener('change', updateTabs);
      }
    });
    
    console.log('Tabbed content initialized:', labels.length, 'tabs');
  });
}

// ============================================
// BUILD NESTED NAVIGATION FROM SUMMARY.MD
// ============================================

async function buildNestedNavigation() {
  console.log('=== BUILDING NESTED NAVIGATION ===');
  
  if (window.nestedNavBuilt) {
    console.log('Already built, skipping');
    return;
  }
  window.nestedNavBuilt = true;
  
  try {
    const baseUrl = typeof base_url !== 'undefined' ? base_url : '/';
    const response = await fetch(baseUrl + 'SUMMARY.md');
    
    if (!response.ok) {
      console.log('Could not fetch SUMMARY.md');
      return;
    }
    
    const summaryText = await response.text();
    const navTree = parseSummary(summaryText);
    
    console.log('Navigation tree parsed, processing groups...');
    
    navTree.forEach(topItem => {
      if (topItem.type === 'group') {
        processGroupForNested(topItem, baseUrl);
      }
    });
    
    console.log('=== NESTED NAVIGATION COMPLETE ===');
  } catch (err) {
    console.error('Error building nested nav:', err);
  }
}

function parseSummary(text) {
  const lines = text.split('\n').filter(l => l.trim());
  const result = [];
  const stack = [{children: result, level: -1}];
  
  lines.forEach(line => {
    const match = line.match(/^(\s*)-\s+(.+)$/);
    if (!match) return;
    
    const indent = match[1].length;
    const content = match[2];
    const level = Math.floor(indent / 2);
    
    const linkMatch = content.match(/\[([^\]]+)\]\(([^)]+)\)/);
    const groupMatch = content.match(/^(.+):$/);
    
    let item;
    if (linkMatch) {
      item = {type: 'link', title: linkMatch[1], path: linkMatch[2], level};
    } else if (groupMatch) {
      item = {type: 'group', title: groupMatch[1], children: [], level};
    } else {
      return;
    }
    
    while (stack[stack.length - 1].level >= level) {
      stack.pop();
    }
    
    stack[stack.length - 1].children.push(item);
    
    if (item.type === 'group') {
      stack.push(item);
    }
  });
  
  return result;
}

function processGroupForNested(group, baseUrl) {
  const labels = document.querySelectorAll('[data-slot="sidebar-group-label"]');
  const matchingLabel = Array.from(labels).find(l => l.textContent.trim() === group.title + ':');
  
  if (!matchingLabel) return;
  
  const menu = matchingLabel.closest('[data-slot="sidebar-group"]')
    .querySelector('[data-slot="sidebar-menu"]');
  
  if (!menu) return;
  
  const nestedFolders = group.children.filter(c => c.type === 'group');
  
  console.log(`Group "${group.title}" has ${nestedFolders.length} nested folders`);
  
  nestedFolders.forEach(folder => {
    createNestedFolder(menu, folder, baseUrl);
  });
}

function createNestedFolder(parentMenu, folder, baseUrl) {
  const currentPath = window.location.pathname;
  
  const li = document.createElement('li');
  li.className = 'nested-folder-item';
  li.style.margin = '2px 0';
  
  const header = document.createElement('div');
  header.className = 'nested-folder-toggle';
  header.innerHTML = `
    <span class="arrow" style="display: inline-block; width: 1rem; transition: transform 0.2s; font-size: 0.7rem;">▸</span>
    <span class="name">${folder.title}</span>
  `;
  header.style.cssText = `
    display: flex;
    align-items: center;
    padding: 0.5rem;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: 500;
    color: var(--{{ css_prefix }}-text-secondary);
    border-radius: 6px;
    transition: background 0.15s, color 0.15s;
  `;
  
  const container = document.createElement('ul');
  container.className = 'nested-folder-items';
  container.style.cssText = `
    list-style: none;
    padding: 0 0 0 1.5rem;
    margin: 0;
    max-height: 0;
    overflow: hidden;
    opacity: 0;
    transition: max-height 0.3s ease, opacity 0.2s ease;
  `;
  
  let hasActive = false;
  
  folder.children.forEach(child => {
    if (child.type !== 'link') return;
    
    const itemLi = document.createElement('li');
    itemLi.style.margin = '0';
    
    const link = document.createElement('a');
    link.href = baseUrl + child.path.replace('.md', '/');
    link.textContent = child.title;
    link.style.cssText = `
      display: block;
      padding: 0.4rem 0.5rem;
      font-size: 0.75rem;
      color: var(--{{ css_prefix }}-text-secondary);
      text-decoration: none;
      border-radius: 4px;
      transition: all 0.15s;
    `;
    
    const isActive = currentPath === link.href || currentPath.includes(link.href);
    if (isActive) {
      link.style.color = 'var(--{{ css_prefix }}-primary)';
      link.style.fontWeight = '600';
      hasActive = true;
    }
    
    link.addEventListener('mouseenter', () => {
      link.style.background = 'var(--{{ css_prefix }}-bg-secondary)';
      link.style.color = 'var(--{{ css_prefix }}-text)';
    });
    
    link.addEventListener('mouseleave', () => {
      link.style.background = 'transparent';
      link.style.color = isActive ? 'var(--{{ css_prefix }}-primary)' : 'var(--{{ css_prefix }}-text-secondary)';
    });
    
    itemLi.appendChild(link);
    container.appendChild(itemLi);
  });
  
  if (hasActive) {
    header.setAttribute('data-expanded', 'true');
    header.querySelector('.arrow').style.transform = 'rotate(90deg)';
    container.style.maxHeight = '1000px';
    container.style.opacity = '1';
  }
  
  header.addEventListener('click', () => {
    const expanded = header.getAttribute('data-expanded') === 'true';
    const arrow = header.querySelector('.arrow');
    
    if (expanded) {
      header.setAttribute('data-expanded', 'false');
      arrow.style.transform = 'rotate(0deg)';
      container.style.maxHeight = '0';
      container.style.opacity = '0';
    } else {
      header.setAttribute('data-expanded', 'true');
      arrow.style.transform = 'rotate(90deg)';
      container.style.maxHeight = '1000px';
      container.style.opacity = '1';
    }
  });
  
  header.addEventListener('mouseenter', () => {
    header.style.background = 'var(--{{ css_prefix }}-bg-secondary)';
    header.style.color = 'var(--{{ css_prefix }}-text)';
  });
  
  header.addEventListener('mouseleave', () => {
    header.style.background = 'transparent';
    header.style.color = 'var(--{{ css_prefix }}-text-secondary)';
  });
  
  li.appendChild(header);
  li.appendChild(container);
  parentMenu.appendChild(li);
  
  console.log(`  Created nested folder "${folder.title}" with ${folder.children.length} items`);
}
