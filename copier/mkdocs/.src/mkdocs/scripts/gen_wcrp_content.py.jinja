#!/usr/bin/env python3
"""
MkDocs Gen Files Script for WCRP-CMIP.org Content
Fetches content from wcrp-cmip.org and generates documentation files
with auto-generated literate navigation that includes existing docs.
"""

import mkdocs_gen_files
import sys
from pathlib import Path
from datetime import datetime
import json
import os

print("🚀 WCRP content generator script started", file=sys.stderr)

# Configuration
OUTPUT_BASE = "wcrp-content"
USE_MOCK_DATA = True  # Set to False when WCRP API is available

# Mock data for testing
MOCK_DATA = {
    "projects": [
        {
            "title": "CMIP6 Data Portal",
            "description": "The Coupled Model Intercomparison Project Phase 6 data portal provides access to climate model output.",
            "content": "CMIP6 represents a major international effort to improve our understanding of climate change.",
            "website": "https://esgf-node.llnl.gov/search/cmip6/",
            "category": "Data Access"
        },
        {
            "title": "DECK Experiments",
            "description": "Diagnostic, Evaluation and Characterization of Klima experiments.",
            "content": "The DECK consists of a set of baseline experiments that all CMIP6 models must complete.",
            "category": "Core Experiments"
        }
    ],
    "news": [
        {
            "title": "CMIP7 Planning Meeting Announced",
            "date": "2024-03-15",
            "summary": "The next planning meeting for CMIP7 will be held in June 2024.",
            "content": "Join us for the upcoming CMIP7 planning meeting where we'll discuss the future of climate modeling.",
            "author": "CMIP Panel"
        }
    ]
}


def scan_existing_docs(docs_dir="../../docs"):
    """Scan existing documentation files and organize them hierarchically."""
    existing_files = {}
    
    if not os.path.exists(docs_dir):
        print(f"⚠️  Docs directory not found: {docs_dir}", file=sys.stderr)
        return existing_files
    
    print(f"📂 Scanning existing docs in: {docs_dir}", file=sys.stderr)
    
    # Scan all markdown files
    for md_file in Path(docs_dir).rglob("*.md"):
        if md_file.name.startswith('.'):
            continue
        
        # Get relative path from docs_dir
        rel_path = md_file.relative_to(docs_dir)
        parts = list(rel_path.parts)
        
        # Skip generated content directory
        if parts and parts[0] == OUTPUT_BASE:
            continue
        
        # Build hierarchy
        current = existing_files
        for i, part in enumerate(parts[:-1]):
            if part not in current:
                current[part] = {}
            current = current[part]
        
        # Add file
        filename = parts[-1]
        title = filename.replace('.md', '').replace('-', ' ').replace('_', ' ').title()
        
        # Special case for common files
        if filename == 'index.md':
            title = 'Home' if len(parts) == 1 else parts[-2].replace('-', ' ').title()
        elif filename == 'README.md':
            title = 'Readme'
        
        current[filename] = {
            'title': title,
            'path': str(rel_path).replace('\\', '/')
        }
    
    return existing_files


def generate_literate_nav_with_existing(sections, existing_files):
    """Generate SUMMARY.md that includes both existing and generated files."""
    nav_content = "# Navigation\n\n"
    
    # Add home if it exists
    if 'index.md' in existing_files:
        nav_content += "* [Home](index.md)\n"
    
    # Add other top-level existing files
    for name, data in sorted(existing_files.items()):
        if name == 'index.md':
            continue
        
        if isinstance(data, dict) and 'title' in data:
            # It's a file
            nav_content += f"* [{data['title']}]({data['path']})\n"
        else:
            # It's a directory
            dir_title = name.replace('-', ' ').replace('_', ' ').title()
            nav_content += f"* {dir_title}\n"
            nav_content += render_nav_section(data, level=1)
    
    # Add generated WCRP content
    if sections:
        nav_content += "* [WCRP Content](wcrp-content/index.md)\n"
        
        for section in sorted(sections.keys()):
            section_title = section.replace('_', ' ').title()
            nav_content += f"    * [{section_title}](wcrp-content/{section}/index.md)\n"
            
            sorted_files = sorted(sections[section], key=lambda x: x[1])
            for filename, file_title in sorted_files:
                nav_content += f"        * [{file_title}](wcrp-content/{section}/{filename})\n"
    
    return nav_content


def render_nav_section(items, level=0):
    """Recursively render navigation section."""
    content = ""
    indent = "    " * level
    
    for name, data in sorted(items.items()):
        if isinstance(data, dict) and 'title' in data:
            # It's a file
            content += f"{indent}* [{data['title']}]({data['path']})\n"
        else:
            # It's a directory
            if 'index.md' in data:
                # Directory with index
                index_data = data['index.md']
                content += f"{indent}* [{index_data['title']}]({index_data['path']})\n"
                
                # Add other files in the directory
                for sub_name, sub_data in sorted(data.items()):
                    if sub_name != 'index.md':
                        if isinstance(sub_data, dict) and 'title' in sub_data:
                            content += f"{indent}    * [{sub_data['title']}]({sub_data['path']})\n"
                        else:
                            # Subdirectory
                            dir_title = sub_name.replace('-', ' ').replace('_', ' ').title()
                            content += f"{indent}    * {dir_title}\n"
                            content += render_nav_section(sub_data, level + 2)
            else:
                # Directory without index
                dir_title = name.replace('-', ' ').replace('_', ' ').title()
                content += f"{indent}* {dir_title}\n"
                content += render_nav_section(data, level + 1)
    
    return content


def extract_title_from_filename(filename: str) -> str:
    """Extract title from filename."""
    name = filename.replace('.md', '')
    parts = name.split('-')
    
    if len(parts) > 1:
        title_parts = parts[1:] if parts[0] in ['projects', 'news', 'activities', 'resources', 'publications', 'working'] else parts
        title = ' '.join(word.capitalize() for word in title_parts)
        return title
    
    return name.replace('-', ' ').title()


def generate_content_file(section: str, item: dict, index: int) -> tuple[str, str]:
    """Generate markdown content file for an item."""
    # Create filename
    title = item.get('title', item.get('name', f'Item {index}'))
    slug = title.lower()
    slug = ''.join(c if c.isalnum() or c == ' ' else '' for c in slug)
    slug = '-'.join(slug.split())
    filename = f"{section}-{slug}.md"
    
    # Generate content
    content = f"# {title}\n\n"
    
    # Add metadata section
    if any(key in item for key in ['date', 'author', 'category', 'tags']):
        content += "---\n"
        for key in ['date', 'author', 'category', 'tags']:
            if key in item:
                content += f"{key}: {item[key]}\n"
        content += "---\n\n"
    
    # Add description/summary
    for key in ['description', 'summary']:
        if key in item:
            content += f"{item[key]}\n\n"
    
    # Add main content
    for key in ['content', 'body']:
        if key in item:
            content += f"{item[key]}\n\n"
    
    # Add additional fields
    for field in ['objectives', 'participants', 'timeline', 'deliverables', 'contact']:
        if field in item:
            content += f"## {field.capitalize()}\n\n{item[field]}\n\n"
    
    # Add links section
    if any(key in item for key in ['website', 'repository', 'documentation']):
        content += "## Links\n\n"
        for key in ['website', 'repository', 'documentation']:
            if key in item:
                content += f"- [{key.capitalize()}]({item[key]})\n"
    
    # Add source attribution
    content += f"\n---\n*Generated on {datetime.now().strftime('%Y-%m-%d')}*\n"
    
    return filename, content


def generate_section_index(section: str, files: list[tuple[str, str]]) -> str:
    """Generate index page for a section."""
    title = section.replace('_', ' ').title()
    content = f"# {title}\n\n"
    content += f"This section contains {len(files)} items.\n\n"
    
    content += "## Contents\n\n"
    for filename, file_title in sorted(files, key=lambda x: x[1]):
        content += f"- [{file_title}]({filename})\n"
    
    return content


def main():
    """Main function to generate all content."""
    print("📥 Generating WCRP content...", file=sys.stderr)
    
    # Scan existing documentation files
    existing_files = scan_existing_docs()
    print(f"📚 Found {sum(1 for _ in Path('../../docs').rglob('*.md')) if os.path.exists('../../docs') else 0} existing files", file=sys.stderr)
    
    all_sections = {}
    
    # Create main index
    main_index_content = """# WCRP-CMIP Content

This section contains automatically generated content from WCRP-CMIP.org.

## Sections

"""
    
    # Process mock data or real API data
    data_source = MOCK_DATA if USE_MOCK_DATA else {}
    
    for section, items in data_source.items():
        if not items:
            continue
            
        print(f"✅ Processing {len(items)} items in {section}", file=sys.stderr)
        
        # Generate files for each item
        section_files = []
        for i, item in enumerate(items):
            filename, content = generate_content_file(section, item, i + 1)
            file_path = f"{OUTPUT_BASE}/{section}/{filename}"
            
            # Write the file using mkdocs-gen-files
            with mkdocs_gen_files.open(file_path, "w") as f:
                f.write(content)
            
            # Extract title for navigation
            title = extract_title_from_filename(filename)
            section_files.append((filename, title))
        
        # Generate section index
        section_index = generate_section_index(section, section_files)
        with mkdocs_gen_files.open(f"{OUTPUT_BASE}/{section}/index.md", "w") as f:
            f.write(section_index)
        
        # Store for navigation
        all_sections[section] = section_files
        
        # Add to main index
        section_title = section.replace('_', ' ').title()
        main_index_content += f"- [{section_title}]({section}/index.md) - {len(section_files)} items\n"
    
    # Write main index
    main_index_content += f"\n---\n*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n"
    with mkdocs_gen_files.open(f"{OUTPUT_BASE}/index.md", "w") as f:
        f.write(main_index_content)
    
    # Generate literate nav file that includes existing docs
    print("📝 Generating navigation file with existing docs...", file=sys.stderr)
    nav_content = generate_literate_nav_with_existing(all_sections, existing_files)
    with mkdocs_gen_files.open("SUMMARY.md", "w") as f:
        f.write(nav_content)
    
    print(f"✅ Content generation complete! Generated {sum(len(files) for files in all_sections.values())} files", file=sys.stderr)


# Call main function when module is loaded
main()
